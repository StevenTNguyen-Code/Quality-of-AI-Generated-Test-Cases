Based on your requirements, the following Java Unit Test cases are created for the given `Ordenacao` class. The test cases cover all the decisions, include boundary values, and ensure full branch coverage.

```java
package ds;

import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.*;
import ds.*;

public class OrdenacaoTest {

    private Ordenacao ordenacao;

    @Before
    public void setUp() throws Exception {
        ordenacao = new Ordenacao();
    }

    @Test(timeout=1000)
    public void testMergeSort_EmptyArray() throws Exception {
        int[] array = {};
        Ordenacao.mergeSort(array, 0, array.length - 1);
        assertArrayEquals(new int[]{}, array);
    }

    @Test(timeout=1000)
    public void testMergeSort_SingleElement() throws Exception {
        int[] array = {42};
        Ordenacao.mergeSort(array, 0, array.length - 1);
        assertArrayEquals(new int[]{42}, array);
    }

    @Test(timeout=1000)
    public void testMergeSort_TwoElements() throws Exception {
        int[] array = {5, 3};
        int[] expected = {3, 5};
        Ordenacao.mergeSort(array, 0, array.length - 1);
        assertArrayEquals(expected, array);
    }

    @Test(timeout=1000)
    public void testMergeSort_SortedArray() throws Exception {
        int[] array = {1, 2, 3, 4, 5};
        int[] expected = {1, 2, 3, 4, 5};
        Ordenacao.mergeSort(array, 0, array.length - 1);
        assertArrayEquals(expected, array);
    }

    @Test(timeout=1000)
    public void testMergeSort_UnsortedArray() throws Exception {
        int[] array = {3, 5, 1, 4, 2};
        int[] expected = {1, 2, 3, 4, 5};
        Ordenacao.mergeSort(array, 0, array.length - 1);
        assertArrayEquals(expected, array);
    }

    @Test(timeout=1000)
    public void testMergeSort_NegativeNumbers() throws Exception {
        int[] array = {-3, -1, -2, -4, -5};
        int[] expected = {-5, -4, -3, -2, -1};
        Ordenacao.mergeSort(array, 0, array.length - 1);
        assertArrayEquals(expected, array);
    }

    @Test(timeout=1000)
    public void testMergeSort_MixedNumbers() throws Exception {
        int[] array = {3, -1, 4, -2, 5};
        int[] expected = {-2, -1, 3, 4, 5};
        Ordenacao.mergeSort(array, 0, array.length - 1);
        assertArrayEquals(expected, array);
    }

    @Test(timeout=1000)
    public void testMergeSort_MixedBoundaryValues() throws Exception {
        int[] array = {-2147483648, 2147483647, 0};
        int[] expected = {-2147483648, 0, 2147483647};
        Ordenacao.mergeSort(array, 0, array.length - 1);
        assertArrayEquals(expected, array);
    }

    // Additional tests to ensure all methods are covered

    @Test(timeout=1000)
    public void testMerge_ValidInput() throws Exception {
        int[] array = {1, 3, 5, 2, 4, 6};
        Ordenacao.merge(array, 0, 2, 5);
        int[] expected = {1, 2, 3, 4, 5, 6};
        assertArrayEquals(expected, array);
    }

    // Test default constructor
    @Test(timeout=1000)
    public void testDefaultConstructor() throws Exception {
        Ordenacao ordenacao = new Ordenacao();
        assertNotNull(ordenacao);
    }
}
```

Explanation:
1. **Imports**: All necessary imports are included.
2. **Setup**: Uses `@Before` method to initialize the `Ordenacao` instance.
3. **Test timeout**: Each test method is decorated with `@Test(timeout=1000)`.
4. **Boundary Values**: Tests include empty array, single element, and mixed boundary values.
5. **Positive and Negative Values**: Both positive and negative integers are tested.
6. **Test for Default Constructor**: Ensures the default constructor can be called.
7. **Coverage**: Each method in the `Ordenacao` class has at least one test case.

The provided tests ensure the `Ordenacao` class is thoroughly tested, including all necessary branches, with appropriate inputs following the specified guidelines.